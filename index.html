<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>For Dasha ‚ù§Ô∏è</title>
<style>
body { margin:0; overflow:hidden; background:black; }
canvas { display:block; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<script>

let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 3000);
camera.position.z = 320;

let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// üåå Bloom
let composer = new THREE.EffectComposer(renderer);
composer.addPass(new THREE.RenderPass(scene,camera));
let bloom = new THREE.UnrealBloomPass(
    new THREE.Vector2(window.innerWidth,window.innerHeight),
    1.2,0.4,0.85
);
composer.addPass(bloom);

// üåå Nebula shader
let nebulaGeo = new THREE.PlaneGeometry(4000,4000);
let nebulaMat = new THREE.ShaderMaterial({
    uniforms:{ time:{value:0} },
    vertexShader:`
        varying vec2 vUv;
        void main(){
            vUv=uv;
            gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
        }
    `,
    fragmentShader:`
        varying vec2 vUv;
        uniform float time;
        float noise(vec2 p){
            return sin(p.x)*sin(p.y);
        }
        void main(){
            vec2 uv=vUv*5.0;
            float n=noise(uv+time*0.1);
            vec3 col=vec3(0.3+0.5*n,0.0+0.3*n,0.4+0.6*n);
            gl_FragColor=vec4(col,1.0);
        }
    `,
    depthWrite:false
});
let nebula = new THREE.Mesh(nebulaGeo,nebulaMat);
nebula.position.z=-1000;
scene.add(nebula);

// ‚≠ê Stars
let starGeo = new THREE.BufferGeometry();
let starCount = 6000;
let starPos = new Float32Array(starCount*3);

for(let i=0;i<starCount;i++){
    starPos[i*3]=(Math.random()-0.5)*2000;
    starPos[i*3+1]=(Math.random()-0.5)*2000;
    starPos[i*3+2]=(Math.random()-0.5)*2000;
}
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos,3));

let starMat = new THREE.PointsMaterial({color:0xffffff,size:1});
let stars = new THREE.Points(starGeo,starMat);
scene.add(stars);

// ‚ú® Particles
let particleCount = 7000;
let geometry = new THREE.BufferGeometry();
let positions = new Float32Array(particleCount*3);

for(let i=0;i<particleCount;i++){
    positions[i*3]=(Math.random()-0.5)*300;
    positions[i*3+1]=(Math.random()-0.5)*300;
    positions[i*3+2]=(Math.random()-0.5)*300;
}
geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));

let material = new THREE.PointsMaterial({
    color:0xff66cc,
    size:1.6
});
let particles = new THREE.Points(geometry,material);
scene.add(particles);

// ‚ù§Ô∏è Heart (–∑ —Ç–µ–∫—Å—Ç–æ–º I LOVE YOU)
let heartTargets = [];
let textString="I LOVE YOU";

for(let i=0;i<particleCount;i++){
    let t=Math.random()*Math.PI*2;

    let x=16*Math.pow(Math.sin(t),3);
    let y=13*Math.cos(t)
          -5*Math.cos(2*t)
          -2*Math.cos(3*t)
          -Math.cos(4*t);

    heartTargets.push({
        x:x*4,
        y:y*4,
        z:(Math.random()-0.5)*60
    });
}

// üíå Text targets
let textTargets=[];
let canvas2=document.createElement("canvas");
let ctx2=canvas2.getContext("2d");
canvas2.width=1800;
canvas2.height=1000;

ctx2.fillStyle="white";
ctx2.font="bold 100px Arial";
ctx2.textAlign="center";

let lines=[
"–î–∞—à–∞, —Å—å–æ–≥–æ–¥–Ω—ñ —è —Ö–æ—á—É –ø–æ–¥–∞—Ä—É–≤–∞—Ç–∏ —Ç–æ–±—ñ –≤—Å–µ—Å–≤—ñ—Ç",
"—Ç–∏ –Ω–∞–π–∫—Ä–∞—â–∞ —ñ —è —Ç–µ–±–µ –ª—é–±–ª—é"
];

lines.forEach((line,i)=>{
    ctx2.fillText(line,900,400+i*170);
});

let data=ctx2.getImageData(0,0,1800,1000);

for(let y=0;y<1000;y+=6){
    for(let x=0;x<1800;x+=6){
        let index=(x+y*1800)*4;
        if(data.data[index+3]>128){
            textTargets.push({
                x:(x-900)/4,
                y:(500-y)/4,
                z:0
            });
        }
    }
}

// ‚è± –¢–∞–π–º—ñ–Ω–≥
let clock=new THREE.Clock();

function animate(){
    requestAnimationFrame(animate);

    let t=clock.getElapsedTime();
    nebulaMat.uniforms.time.value=t;
    stars.rotation.y+=0.0005;

    let pos=particles.geometry.attributes.position.array;
    let targetSet;

    if(t<6){
        targetSet=textTargets;
    }
    else if(t<16){
        targetSet=textTargets;
    }
    else{
        targetSet=heartTargets;
        particles.rotation.y+=0.004;
        particles.rotation.x=Math.sin(t)*0.2;

        let pulse=1+Math.sin(t*3)*0.05;
        particles.scale.set(pulse,pulse,pulse);
    }

    for(let i=0;i<particleCount;i++){
        let target=targetSet[i%targetSet.length];
        pos[i*3]+=(target.x-pos[i*3])*0.02;
        pos[i*3+1]+=(target.y-pos[i*3+1])*0.02;
        pos[i*3+2]+=(target.z-pos[i*3+2])*0.02;
    }

    particles.geometry.attributes.position.needsUpdate=true;

    composer.render();
}

animate();

window.addEventListener("resize",()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
    composer.setSize(window.innerWidth,window.innerHeight);
});
</script>

</body>
</html>
